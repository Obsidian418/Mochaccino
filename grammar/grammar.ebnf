################################
# LITERALS #####################
################################
literal = NUMBER
        | STRING
        | "true"
        | "false"
        | "null"
        | array_literal
        | map_literal
;
array_literal = "[" 
                    (term)
                    (
                      "," (term)
                    )*
                "]"
;
map_literal = "{" 
                  (term ":" term)
                  (
                    "," (term ":" term)
                  )*
              "}"
;
func_call = identifier ("." identifier)* "(" params ")";
kw_ok = "ok";
kw_notok = "notok";
kw_named = "named";
kw_package = "package";
kw_include = "include";
kw_from = "from";
kw_as = "as";
kw_guarded = "guarded";
kw_except = "except";
kw_var = "var";
kw_return = "return";
kw_async = "async";
kw_static = "static";
kw_module = "module":
kw_struct = "struct";
kw_func = "func";
kw_dock = "dock";
kw_extends = "extends";
kw_implements = "implements";
kw_if = "if";
kw_elif = "elif";
kw_else = "else";
kw_for = "for";
kw_while = "while";
kw_prop = "prop";
kw_get = "get";
kw_set = "set";


###################
# GENERIC
###################
program = (statement | block)*;
statement = package_decl
          | include_decl
          | import_decl
          | assignment
          | debug_flag
          | struct_annotation
          | kw_ok
          | kw_notok
          | expression
          | prop_const
;
block = dock_block
      | module_block
      | struct_block
      | func_decl
      | if_block
      | for_loop
      | while_loop
      | prop_block
;
type_annotation = "<"
                    TYPE 
                    ["," type_annotation] 
                  ">"
;
params = (
            ([kw_named] (identifier | expression) [type_annotation])
            ("," [kw_named] (identifier | expression) [type_annotation])*
         )*
;

###################
# STATEMENTS
###################
package_decl = kw_package identifier ";";
include_decl = kw_include identifier ";";
import_decl = " "*
            (| STRING
            | identifier kw_from STRING
            | identifier kw_from STRING kw_as identifier
            )  ";"
;
assignment = (initialiser | reassignment) ";";
reassignment = identifier "=" expression  ";";
initialiser = kw_var identifier [type_annotation] "=" expression  ";";
prop_const = kw_prop identifier ";";
debug_flag = "#" identifier [":" TEXT] "\n";
struct_annotation = "@elementary"
                  | "@protocol"
                  | "@enum"
                  | "@abstract"
;

###################
# BLOCKS
###################
dock_block = kw_dock "{"
                (import_decl)*
             "}"
;
module_block = kw_module TYPE [kw_implements TYPE] "{"
                (statement)*
               "}"
;
struct_block = kw_struct TYPE [(kw_extends|kw_implements) TYPE] "{"
                (struct_annotation)+
                (statement)*
               "}"
;
func_decl = kw_func " " identifier "(" params ")" type_annotation [kw_async] "{"
            (statement)*
            "}"
;
if_block = (
              kw_if "(" comparative_exp ")" "{" (statement)* "}"
              [(kw_elif "(" comparative_exp ")" "{" (statement)* "}")*]
              [kw_else "{" (statement)* "}"]
           )
;
for_loop = (
              kw_for "(" [initialiser] ";" [comparative_exp] ";" [expression] ";" ")"
              "{"
                  (statement)*
              "}"
           )
;
while_loop = (
              kw_while "(" (binary_exp | comparative_exp) ")"
              "{"
                  (statement)*
              "}"
             )
;
prop_block = kw_prop identifier type_annotation
            "{"
                [
                  kw_get "{"
                    (statement)*
                  "}"
                ]
                [
                  kw_set "{"
                    (statement)*
                  "}"
                ]
            "}"
;

###################
# EXPRESSIONS
###################
expression = binary_exp | unary_exp | comparative_exp | logical_exp | group | term;
group = "(" expression ")";
logical_exp = expression logical_op expression;
binary_exp = expression arithmetic_op expression;
unary_exp = (unary_prefix (unary_exp | term)) | ((unary_exp | term) unary_postfix);
comparative_exp = expression comparative_op expression;
arithmetic_op = "+" | "-" | "*" | "/" | "%";
logical_op = "||" | "&&";
comparative_op = "==" | "!=" | "<" | ">" | "<=" | ">=";
unary_prefix = "!" | "-";
unary_postfix = "++" | "--";


###################
# EXPRESSIONS 2.1
###################
# TEST: 1 + 2 / 3 < 4 == 5 * (1+2) > -10
# EXPECTED: true
expression = binary_exp | group | term;
term = literal | identifier | func_call;
group = "(" expression ")";
binary_exp = binary_exp binary_op unary_exp | unary_exp;
unary_exp = unary_prefix | unary_postfix;
unary_prefix = ["-" | "!"] term;
unary_postfix = term ["++" | "--"];
binary_op = arithmetic_op | comparative_op | logical_op;
arithmetic_op = "/" | "*" | "+" | "-";
comparative_op = "==" | "!=" | ">" | ">=" | "<" | "<=";
logical_op = "||" | "&&";